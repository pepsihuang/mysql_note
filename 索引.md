

### 作用

提高数据查询效率

### 常用索引模型

1. 哈希表
2. 有序数组
3. 搜索树

#### 哈希表 
思路:把值放在数组里, 用一个哈希函数把key换算成一个确定位置,然后把value放在数组的这个位置.

冲突处理方法: 链表
适用场景: 等值查询

#### 有序数组

思路: 按顺序存储. 使用二分法进行快速查询复杂度为: O(logN)

优缺点: 查询效率高,更新效率低. 

适用场景: 静态存储引擎.
   
### 索引类型

1. 主键索引(聚族索引)
2. 非主键索引(二级索引)

两者区别: 

非主键索引需要先搜索指定的索引,然后在再去主键索引树上搜索,所以非主键索引需要多搜索一棵树.(此过程称之为 `回表`)


#### 索引维护

B+树具有有序性. 所以中间插入新值,需要做维护.

如果是在中间插入,并且此时所在的数据页满了. 则需要申请一个新的数据页,并且挪动部分数据过去. 此过程为 `页分裂`. (影响性能)

当两个相邻的页删除了些数据,利用率很多,将会发生`合并`.

所以此时可以发现使用自增主键将提高性能.

自增主键定义: 

~~~
NOT NULL PRIMARY KEY AUTO_INCREMENT
~~~

非主键索引的叶子节点上都是主键的值.

**主键长度越小,普通索引的叶子节点就越小.普通索引占用的空间越小.**

适合直接使用主键作为索引的场景:

1. 只有一个索引
2. 该索引必须是唯一索引
3. 


### 覆盖索引

在非主键索引树上就能直接提供查询结果，不需要回表。

覆盖索引可以减少树的搜索次数，从而显著提高查询性能。所以是一种常用性能优化手段。

### 前缀索引

为利用B+树的索引结构 **“最左前缀”** ，来定位记录。

索引项是按照索引定义里面出现的字段顺序排序的。

e.g 搜素名字第一个字是 ‘张’ 的人
```
where name like '张'
```

该命令就会遍历到第一个‘张’的人，一直遍历到最后一个，就结束了。

在建立联合索引时，应该注意索引内的字段顺序。如果通过顺序调整，可以少维护一个索引，那么这个顺序是需要优先考虑采用的。

### 索引下推

可以在索引遍历过程中对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。



---

**问题**

1. 二叉树是左子节点<父节点<右子节点. 那N叉树是怎么判断?

---

**关键字**

N叉树

B+树

数据页

联合索引
