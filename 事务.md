

## 多个事务同时执行

可能出现的问题: 
1. 脏读 dirty read
2. 不可重复读
3. 幻读


## 隔离性

*ACID原则*
1. 原子性
2. 一致性
3. 隔离性
4. 持久性

## 隔离级别

1. 读未提交 : 一个事务还没提交时,它做的变更可被别的事务看到
2. 读提交 :  一个事务提交之后,它做的变更才被别的事务看到
3. 可重复读 : 一个事务执行过程中看到的数据总是跟启动时看到的数据一致.且没提交的变更对其他事务不可见.
4. 串行化 : 对同一行记录, '写'加'写锁' ,  '读'加'读锁'. 当出现写锁冲突时,后面事务必须要等前一个事务执行完成.

## 事务隔离的实现

MySQL中每条记录更新时记录一条回滚操作. 记录最新值,这样通过回滚操作即可得到状态前一个值. 同一条记录再系统中可以存在多个版本,即数据库的多版本并发控制(MVCC)

以'可重复读'为例
不同时间启动的事务,看到的值不一样.(不同的read-view)

当系统判断没有事务再需要这些回滚日志时,日志会被删除.

长事务会占用大量存储空间.还会占用锁资源.

## 事务的启动方式

1. 显式启动事务语句, begin或start transaction. 提交语句commint.回滚语句rollback.
2. set autocommit=0,本命令会把自动提交关掉.这样只要执行一个select语句,事务就会启动,并不会自动提交,直到主动commit或者rollback.

建议使用方法1.当觉得使用方法1会多一次交互,则可以使用 commit work and chain语法. 这样是提交事务并自动启动下一个事务.省去了begin开销. 

## 查询长事务

查询持续时间超过60秒的事务:

    `select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60`
